#include "stdafx.h"

using namespace std;

#ifdef __LP64__
typedef int intblas;
typedef int integer;
#else
typedef long intblas;
typedef long integer;
#endif

typedef integer logical;
typedef double doublereal;
typedef integer ftnlen;

#define real LAPACK_real
#include "cpplapack.h"
#undef real


//=================================================================================================================//
// Lapack interface for getting inverse of a matrix 
//=================================================================================================================//	
long lapack_inv(double* A, int N) {
    int *pivotArray = new int[N+1];
    int LWORK = N*N;
    double *WORK = new double[LWORK];
    int errorHandler;

    dgetrf_(&N,&N,A,&N,pivotArray,&errorHandler);
    dgetri_(&N,A,&N,pivotArray,WORK,&LWORK,&errorHandler);

  return 0;
}
//=================================================================================================================//

//=================================================================================================================//
// Lapack interface for getting inverse of a matrix 
//=================================================================================================================//	
long lapack_test(double** A, int N) {
    int *pivotArray = new int[N+1];
    int LWORK = N*N;
    double *WORK = new double[LWORK];
    int errorHandler;
    int cc=0;
    
    double * AA =  new double[16];
    for(int jj=0; jj<4; jj++)
        for(int kk=0; kk<4; kk++){
           AA[cc]=A[jj][kk]; cc++;}
   
    dgetrf_(&N,&N,AA,&N,pivotArray,&errorHandler);
    dgetri_(&N,AA,&N,pivotArray,WORK,&LWORK,&errorHandler);
   
    cc=0;
    for(int jj=0; jj<4; jj++)
        for(int kk=0; kk<4; kk++){
           A[jj][kk]=AA[cc]; cc++;}
           
  return 0;
}
//=================================================================================================================//

//=================================================================================================================//

//=================================================================================================================//
// Hardcoded 4D matrix inverse 
//=================================================================================================================//
int hardcoded_4Dinv(double** A) {
    double detA =
 A[0][0]*A[1][1]*A[2][2]*A[3][3]+A[0][0]*A[1][2]*A[2][3]*A[3][1]+A[0][0]*A[1][3]*A[2][1]*A[3][2]
+A[0][1]*A[1][0]*A[2][3]*A[3][2]+A[0][1]*A[1][2]*A[2][0]*A[3][3]+A[0][1]*A[1][3]*A[2][2]*A[3][0]
+A[0][2]*A[1][0]*A[2][1]*A[3][3]+A[0][2]*A[1][1]*A[2][3]*A[3][0]+A[0][2]*A[1][3]*A[2][0]*A[3][1]
+A[0][3]*A[1][0]*A[2][2]*A[3][1]+A[0][3]*A[1][1]*A[2][0]*A[3][2]+A[0][3]*A[1][2]*A[2][1]*A[3][0]
-A[0][0]*A[1][1]*A[2][3]*A[3][2]-A[0][0]*A[1][2]*A[2][1]*A[3][3]-A[0][0]*A[1][3]*A[2][2]*A[3][1]
-A[0][1]*A[1][0]*A[2][2]*A[3][3]-A[0][1]*A[1][2]*A[2][3]*A[3][0]-A[0][1]*A[1][3]*A[2][0]*A[3][2]
-A[0][2]*A[1][0]*A[2][3]*A[3][1]-A[0][2]*A[1][1]*A[2][0]*A[3][3]-A[0][2]*A[1][3]*A[2][1]*A[3][0]
-A[0][3]*A[1][0]*A[2][1]*A[3][2]-A[0][3]*A[1][1]*A[2][2]*A[3][0]-A[0][3]*A[1][2]*A[2][0]*A[3][1];

double 
b00=A[1][1]*A[2][2]*A[3][3]+A[1][2]*A[2][3]*A[3][1]+A[1][3]*A[2][1]*A[3][2]-A[1][1]*A[2][3]*A[3][2]-A[1][2]*A[2][1]*A[3][3]-A[1][3]*A[2][2]*A[3][1],
b01=A[0][1]*A[2][3]*A[3][2]+A[0][2]*A[2][1]*A[3][3]+A[0][3]*A[2][2]*A[3][1]-A[0][1]*A[2][2]*A[3][3]-A[0][2]*A[2][3]*A[3][1]-A[0][3]*A[2][1]*A[3][2],
b02=A[0][1]*A[1][2]*A[3][3]+A[0][2]*A[1][3]*A[3][1]+A[0][3]*A[1][1]*A[3][2]-A[0][1]*A[1][3]*A[3][2]-A[0][2]*A[1][1]*A[3][3]-A[0][3]*A[1][2]*A[3][1],
b03=A[0][1]*A[1][3]*A[2][2]+A[0][2]*A[1][1]*A[2][3]+A[0][3]*A[1][2]*A[2][1]-A[0][1]*A[1][2]*A[2][3]-A[0][2]*A[1][3]*A[2][1]-A[0][3]*A[1][1]*A[2][2],
b10=A[1][0]*A[2][3]*A[3][2]+A[1][2]*A[2][0]*A[3][3]+A[1][3]*A[2][2]*A[3][0]-A[1][0]*A[2][2]*A[3][3]-A[1][2]*A[2][3]*A[3][0]-A[1][3]*A[2][0]*A[3][2],
b11=A[0][0]*A[2][2]*A[3][3]+A[0][2]*A[2][3]*A[3][0]+A[0][3]*A[2][0]*A[3][2]-A[0][0]*A[2][3]*A[3][2]-A[0][2]*A[2][0]*A[3][3]-A[0][3]*A[2][2]*A[3][0],
b12=A[0][0]*A[1][3]*A[3][2]+A[0][2]*A[1][0]*A[3][3]+A[0][3]*A[1][2]*A[3][0]-A[0][0]*A[1][2]*A[3][3]-A[0][2]*A[1][3]*A[3][0]-A[0][3]*A[1][0]*A[3][2],
b13=A[0][0]*A[1][2]*A[2][3]+A[0][2]*A[1][3]*A[2][0]+A[0][3]*A[1][0]*A[2][2]-A[0][0]*A[1][3]*A[2][2]-A[0][2]*A[1][0]*A[2][3]-A[0][3]*A[1][2]*A[2][0],
b20=A[1][0]*A[2][1]*A[3][3]+A[1][1]*A[2][3]*A[3][0]+A[1][3]*A[2][0]*A[3][1]-A[1][0]*A[2][3]*A[3][1]-A[1][1]*A[2][0]*A[3][3]-A[1][3]*A[2][1]*A[3][0],
b21=A[0][0]*A[2][3]*A[3][1]+A[0][1]*A[2][0]*A[3][3]+A[0][3]*A[2][1]*A[3][0]-A[0][0]*A[2][1]*A[3][3]-A[0][1]*A[2][3]*A[3][0]-A[0][3]*A[2][0]*A[3][1],
b22=A[0][0]*A[1][1]*A[3][3]+A[0][1]*A[1][3]*A[3][0]+A[0][3]*A[1][0]*A[3][1]-A[0][0]*A[1][3]*A[3][1]-A[0][1]*A[1][0]*A[3][3]-A[0][3]*A[1][1]*A[3][0],
b23=A[0][0]*A[1][3]*A[2][1]+A[0][1]*A[1][0]*A[2][3]+A[0][3]*A[1][1]*A[2][0]-A[0][0]*A[1][1]*A[2][3]-A[0][1]*A[1][3]*A[2][0]-A[0][3]*A[1][0]*A[2][1],
b30=A[1][0]*A[2][2]*A[3][1]+A[1][1]*A[2][0]*A[3][2]+A[1][2]*A[2][1]*A[3][0]-A[1][0]*A[2][1]*A[3][2]-A[1][1]*A[2][2]*A[3][0]-A[1][2]*A[2][0]*A[3][1],
b31=A[0][0]*A[2][1]*A[3][2]+A[0][1]*A[2][2]*A[3][0]+A[0][2]*A[2][0]*A[3][1]-A[0][0]*A[2][2]*A[3][1]-A[0][1]*A[2][0]*A[3][2]-A[0][2]*A[2][1]*A[3][0],
b32=A[0][0]*A[1][2]*A[3][1]+A[0][1]*A[1][0]*A[3][2]+A[0][2]*A[1][1]*A[3][0]-A[0][0]*A[1][1]*A[3][2]-A[0][1]*A[1][2]*A[3][0]-A[0][2]*A[1][0]*A[3][1],
b33=A[0][0]*A[1][1]*A[2][2]+A[0][1]*A[1][2]*A[2][0]+A[0][2]*A[1][0]*A[2][1]-A[0][0]*A[1][2]*A[2][1]-A[0][1]*A[1][0]*A[2][2]-A[0][2]*A[1][1]*A[2][0];

A[0][0]=b00/detA;
A[0][1]=b01/detA;
A[0][2]=b02/detA;
A[0][3]=b03/detA;
A[1][0]=b10/detA;
A[1][1]=b11/detA;
A[1][2]=b12/detA;
A[1][3]=b13/detA;
A[2][0]=b20/detA;
A[2][1]=b21/detA;
A[2][2]=b22/detA;  
A[2][3]=b23/detA;
A[3][0]=b30/detA;
A[3][1]=b31/detA;
A[3][2]=b32/detA;
A[3][3]=b33/detA;


return 0;
}
